Design
------

> 1. To implement `Filesystem::debug`, you will need to load the file system
>    data structures and report the **superblock** and **inodes**.
>       - How will you read the superblock?
>       - How will you traverse all the inodes?
>       - How will you determine all the information related to an inode?
>       - How will you determine all the blocks related to an inode?

Response.

1. 调用 `Disk::read()` 读取磁盘上第一块的数据

2. 两层循环，外层循环遍历存储 inode 的 block，内层循环遍历 block 中的inode

3. 通过 Inode 数据结构获取 inode 的有效性(Valid)和数据长度(Size)

4. 1) Direct Block，通过遍历 Inode 中的 Direct 数组得到

   2) Indirect Data Block，如果存在的话，首先根据 Inode 中的 Indirect 得到存储指针的 block，之后遍历 block 中的 Pointer 得到所有 Indirect Data Block

   3) 无论是 Direct Block , Indirect Block，还是  Indirect Data Block，如果得到的 block number 为0，就认为该项在 inode 中是无效的或者说是没有被用到

> 2. To implement `FileSystem::format`, you will need to write the superblock
>    and clear the remaining blocks in the file system.
>       - What pre-condition must be true before this operation can succeed?
>       - What information must be written into the superblock?
>       - How would you clear all the remaining blocks?

Response.

1. disk 没有被挂载
2. SuperBlock 结构中的四项：MagicNumber 、Blocks 、InodeBlocks 、 Inodes
3. 对 disk 中除 SuperBlock 以外的所有 block 遍历，调用 `Disk::write()` 对所有块写入 (Block) block= {0} 

> 3. To implement `FileSystem::mount`, you will need to prepare a filesystem
>    for use by reading the superblock and allocating the free block bitmap.
>       - What pre-condition must be true before this operation can succeed?
>       - What sanity checks must you perform?
>       - How will you record that you mounted a disk?
>       - How will you determine which blocks are free?

Response.

1. ① 文件系统没有被挂载，② disk 中的 SuperBlock 经过验证没有错误

2. 对 disk 的 SuperBlock 结构中的以下四项做验证：① MagicNumber是否正确； ② Blocks 是否等于 disk 中实际的块数； ③ Inode Blocks数目是否占了disk块总数的10%(向上取整)； ④ Inode 数目是否与Inode Blocks的数目匹配

3. 在 FileSystem 中增加有一个Disk *disk，如果为0，表示没有挂载；否则指向挂载的disk

4. 在FileSystem中加一个 bool 类型的 freemap 数组，以bitmap的方式记录空闲块，如果空闲，对应值为true：

   - 对 freemap 初始化，长度等于disk中的块数，所有值都初始化为true

   - SuperBlock 和 Inode Blocks不是空闲的，在 freemap 设为 false
   - 遍历所有的 Inode Block，遍历其中所有有效的 Inode，其中Direct Block，Indirect Block 以及 Indirect Data Block不是空闲的；

> 4. To implement `FileSystem::create`, you will need to locate a free inode
>    and save a new inode into the inode table.
>   - How will you locate a free inode?
>       - What information would you see in a new inode?
>       - How will you record this new inode?

Response.

1. 从第一个Inode Block开始遍历所有的Inode，选取第一个 Valid=0 的inode
2. Vallid=1，Size=0，Direct[0…4]=0，Indirect=0
3. 调用 `Disk::write()` 写入

> 5. To implement `FileSystem::remove`, you will need to locate the inode and
>    then free its associated blocks.
>   - How will you determine if the specified inode is valid?
>       - How will you free the direct blocks?
>       - How will you free the indirect blocks?
>       - How will you update the inode table?

Response.

1. 判断 inumber 是否大于或等于 disk 上 inode 总数，如果是，那么找不到对应的 inode；如果有对应的 inode，根据 inumber 得到对应的 inode，根据 Valid 判断是否有效
2. 在空闲块的 freemap 中将所有Direct Block标记为 true，且 inode 中对应Direct数组项设为0
3. 根据 Indirect 读取 Indirect Block，如果在 inode 中存在的话，
   - 遍历 Indirect Block 所有指针，将所有指针项设为0
   - 在空闲块的 freemap 中将所有 inode 中用到的 Indirect Data Block 记为空闲
   - 将空闲块的 freemap 中 Indirect Block 对应项记为空闲
4. 将 Valid 和 Size 都设为0之后存入
   - 读出 inode 所在的 Inode Block
   - 将 inode 存入读出的 Inode Block 中
   - 再将 Inode Block 写回

> 6. To implement `FileSystem::stat`, you will need to locate the inode and
>    return its size.
>   - How will you determine if the specified inode is valid?
>       - How will you determine the inode's size?

Response.

1. 判断 inumber 是否大于或等于 disk 上 inode 总数，如果是，那么找不到对应的 inode 或者说 inode 无效；将 inode 读出后，根据 Valid 判断是否有效
2. 如果 inode 无效，函数返回-1，如果有效，返回 Size

> 7. To implement `FileSystem::read`, you will need to locate the inode and
>    copy data from appropriate blocks to the user-specified data buffer.
>   - How will you determine if the specified inode is valid?
>       - How will you determine which block to read from?
>       - How will you handle the offset?
>       - How will you copy from a block to the data buffer?

Response.

1. 判断 inumber 是否大于或等于 disk 上 inode 总数，如果是，那么找不到对应的 inode 或者说 inode 无效；将 inode 读出后，根据 Valid 判断是否有效
2. 从 offset / BlockSize(4096)开始读起，之后按照 inode 存放数据的块的顺序来读取数据，直到读取到 length 长度的数据或者遇到文件末尾
3. 由 offset % BlockSize(4096) 可以得到在第一个读取块中的偏移，后面所有块都从0位开始读起
4. 使用 memcpy，将读到的数据复制到 data + hasRead，hasRead是当前已经读取到的数据，也是已经复制到 data buffer 的长度，当前复制目的地的起始位置；复制长度=min{读到数据长度，剩余需要读取内容长度}

> 8. To implement `FileSystem::write`, you will need to locate the inode and
>    copy data the user-specified data buffer to data blocks in the file
>    system.
>   - How will you determine if the specified inode is valid?
>       - How will you determine which block to write to?
>       - How will you handle the offset?
>       - How will you know if you need a new block?
>       - How will you manage allocating a new block if you need another one?
>       - How will you copy from a block to the data buffer?
>       - How will you update the inode?

Response.

1. 判断 inumber 是否大于或等于 disk 上 inode 总数，如果是，那么找不到对应的 inode 或者说 inode 无效；将 inode 读出后，根据 Valid 判断是否有效

2. 从 offset / BlockSize(4096)开始写入，之后按照 inode 存放数据的块的顺序来写入数据，如果超出了inode的块数，那么分配新的块，直到写入 length 长度的数据或者disk上没有空闲块

3. 由 offset % BlockSize(4096) 可以得到在第一个写入块中的偏移，后面所有块都从0位开始写入

4. 对于 Direct Block，如果对应的 inode.Direct 数组项值为0，需要分配新的块；对于 Indirect Data Block，如果 inode.Indirect = 0，那么需要为分配两个新的块，一个是 Indirect Block，另一个作为 Indirect Data Block，如果Indirect不为0，但是Pointer 为0，那么只需要分配一个新的数据块

5. 遍历 freemap 得到空闲块，如果只是分配一个数据块，那么一旦分配就可以用；如果既要分配 Indirect Block 又要分配一个数据块，那么在分配完 Indirect Block 之后需要判断是否仍有空闲块，如果没有的话，那么分配的 Indirect Block 需要还回；

   所有分配的新块，都需要在 freemap 中标记为占用；并在 inode 中做对应记录

6. 使用 memcpy，将 data+hasWrite 指向的数据复制到块中根据offset判断的起始位置，hasWrite是以写入数据；复制长度=min{块的大小-offset，剩余要复制的数据长度}

Errata
------

> Describe any known errors, bugs, or deviations from the requirements.

Extra Credit
------------

> Describe what extra credit (if any) that you implemented.

## Presentation

> Show your result.

```shell
$ make test
Testing cat on data/image.5 ... Success
Testing cat on data/image.20 ... Failure
--- /dev/fd/63  2020-05-28 18:39:58.570413395 +0800
+++ /dev/fd/62  2020-05-28 18:39:58.570413395 +0800
@@ -143,7 +143,7 @@
 
 0 bytes copied
 0 disk block writes
-20 disk block reads
+21 disk block reads
 27160 bytes copied
 9546 bytes copied
    Abraham Clark
Testing copyin in /tmp/tmp.8RSI0s5JDP/image.5 ... Success
Testing copyin in /tmp/tmp.8RSI0s5JDP/image.20 ... Success
Testing copyin in /tmp/tmp.8RSI0s5JDP/image.200 ... Success
Testing copyout in data/image.5 ... Success
Testing copyout in data/image.20 ... Success
Testing copyout in data/image.200 ... Success
Testing create in data/image.5.create ... --- /dev/fd/63        2020-05-28 18:39:58.802422810 +0800
+++ /dev/fd/62  2020-05-28 18:39:58.802422810 +0800
@@ -524,5 +524,5 @@
 Inode 127:
     size: 0 bytes
     direct blocks:
-134 disk block reads
+261 disk block reads
 127 disk block writes
False
Testing debug on data/image.5 ... Success
Testing debug on data/image.20 ... Success
Testing debug on data/image.200 ... Success
Testing format on data/image.5.formatted ... Success
Testing format on data/image.20.formatted ... Success
Testing format on data/image.200.formatted ... Success
Testing mount on data/image.5 ... Success
Testing mount-mount on data/image.5 ... Success
Testing mount-format on data/image.5 ... Success
Testing bad-mount on /tmp/tmp.rn4VGk3Znk/image.5 ... Success
Testing bad-mount on /tmp/tmp.rn4VGk3Znk/image.5 ... Success
Testing bad-mount on /tmp/tmp.rn4VGk3Znk/image.5 ... Success
Testing bad-mount on /tmp/tmp.rn4VGk3Znk/image.5 ... Success
Testing bad-mount on /tmp/tmp.rn4VGk3Znk/image.5 ... Success
Testing remove in /tmp/tmp.1ujmVdpnlj/image.5 ... False
--- /dev/fd/63  2020-05-28 18:39:59.130436129 +0800
+++ /dev/fd/62  2020-05-28 18:39:59.130436129 +0800
@@ -38,5 +38,5 @@
 Inode 2:
     size: 0 bytes
     direct blocks:
-21 disk block reads
+25 disk block reads
 8 disk block writes
Testing remove in /tmp/tmp.1ujmVdpnlj/image.5 ... False
--- /dev/fd/63  2020-05-28 18:39:59.142436616 +0800
+++ /dev/fd/62  2020-05-28 18:39:59.142436616 +0800
@@ -54,5 +54,5 @@
 Inode 2:
     size: 965 bytes
     direct blocks: 4
-30 disk block reads
-13 disk block writes
+27 disk block reads
+10 disk block writes
Testing remove in /tmp/tmp.1ujmVdpnlj/image.20 ... False
--- /dev/fd/63  2020-05-28 18:39:59.170437753 +0800
+++ /dev/fd/62  2020-05-28 18:39:59.170437753 +0800
@@ -41,5 +41,5 @@
     direct blocks: 4 5 6 7 8
     indirect block: 9
     indirect data blocks: 13 14
-40 disk block reads
-12 disk block writes
+41 disk block reads
+18 disk block writes
Testing stat on data/image.5 ... Success
Testing stat on data/image.20 ... Success
Testing stat on data/image.200 ... Success
Testing valgrind on /tmp/tmp.E5OtDncEbB/image.200 ... Success
```

